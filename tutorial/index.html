<!DOCTYPE html><html><head><link href="META-INF/resources/webjars/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" /><link href="styles.css" rel="stylesheet" /><link rel="shortcut icon" type="image/png" href="favicon.png" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><style>
.scalatex-site-Styles-headerLink{
  color: #777;
  opacity: 0.05;
  text-decoration: none;
}


.scalatex-site-Styles-hoverContainer:hover .scalatex-site-Styles-headerLink{
  color: #777;
  opacity: 0.5;
  text-decoration: none;
}
.scalatex-site-Styles-hoverContainer:hover .scalatex-site-Styles-headerLink:hover{
  opacity: 1.0;
}
.scalatex-site-Styles-hoverContainer:hover .scalatex-site-Styles-headerLink:active{
  opacity: 0.75;
}

.scalatex-site-Styles-content{
  color: #777;
  line-height: 1.6em;
  margin: 0 auto;
  margin-left: auto;
  margin-right: auto;
  max-width: 800px;
  padding: 0 1em;
  padding-bottom: 50px;
}
.scalatex-site-Styles-content *{
  position: relative;
}
.scalatex-site-Styles-content p{
  text-align: justify;
}
.scalatex-site-Styles-content a:link{
  color: #37a;
  text-decoration: none;
}
.scalatex-site-Styles-content a:visited{
  color: #949;
  text-decoration: none;
}
.scalatex-site-Styles-content a:hover{
  text-decoration: underline;
}
.scalatex-site-Styles-content a:active{
  color: #000;
  text-decoration: underline;
}
.scalatex-site-Styles-content code{
  color: #000;
}

/*Workaround for bug in highlight.js IDEA theme*/
span.hljs-tag, span.hljs-symbol{
    background: none;
}
    </style><title>A Whirlwind Tour of Scalameta</title><script src="scripts.js"></script></head><body><div>


  <a href="https://github.com/olafurpg/scala.meta-workshop"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/652c5b9acfaddf3a9c326fa6bde407b87f7be0f4/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6f72616e67655f6666373630302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png"></a>

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="AWhirlwindTourofScalameta" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">A Whirlwind Tour of Scalameta<a class=" scalatex-site-Styles-headerLink" href="#AWhirlwindTourofScalameta" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div><div class=" scalatex-site-Styles-content">
  <p>
    For any Scalameta related questions, don't hesitate to ask on our gitter channel:
    <a href="https://gitter.im/scalameta/scalameta?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge"><img src="https://camo.githubusercontent.com/da2edb525cde1455a622c58c0effc3a90b9a181c/68747470733a2f2f6261646765732e6769747465722e696d2f4a6f696e253230436861742e737667" alt="Join the chat at https://gitter.im/scalameta/scalameta" data-canonical-src="https://badges.gitter.im/Join%20Chat.svg" style="max-width:100%;"></a></p>
  <p>
    <b>Note.</b> This tutorial was originally created for a workshop at the
    <a href="http://scala.world">scala.world</a> conference.
    The workshop material turned out to be useful for many so it has been moved here.
    You will still find occasional references to scala.world.</p>
  


  

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Setup" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Setup<a class=" scalatex-site-Styles-headerLink" href="#Setup" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
  There are several ways to install and run Scalameta.

  <h1 id="Library" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Library" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Library</h1>
    You can use Scalameta as a library, the <code>scalameta</code> umbrella package
    includes modules for trees, tokens, parsing, pretty printing, semantic API
    and more,
    <pre><code class="scala scalatex-site-Styles-highlightMe">libraryDependencies += &quot;org.scalameta&quot; %% &quot;scalameta&quot; % &quot;2.1.2&quot;
</code></pre>
    Optionally, for extra utilities, you can use <a href="#Contrib">Contrib</a>
    <pre><code class="scala scalatex-site-Styles-highlightMe">libraryDependencies += &quot;org.scalameta&quot; %% &quot;contrib&quot; % &quot;2.1.2&quot;
</code></pre>
  <h1 id="Tutorial" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Tutorial" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Tutorial</h1>
    The examples mentioned in this tutorial are available in a single repository
    that you can clone and run locally.
    <ol>
      <li>
        Clone the <a href="https://github.com/scalameta/tutorial">workshop repo</a>.
        Alternatively, for a minimal project template that uses the bleeding edge
        version of scalameta/paradise, clone
        <a href="https://github.com/olafurpg/scalameta-macro-template">this repo</a>.</li>
      <li>
        Run <code>sbt test</code> to make sure everything works.</li>
      <li>
        Open the file <code>Playground.scala</code>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">package scalaworld

import scala.meta._
import org.scalameta.logger // useful for debugging

class Playground extends org.scalatest.FunSuite {
  import scala.meta._

  test(&quot;part 1: tokens&quot;) {
    val tokens = &quot;val x = 2&quot;.tokenize.get
    logger.elem(tokens.syntax)
    logger.elem(tokens.structure)
  }

  test(&quot;part 2: trees&quot;) {
    val tree = &quot;val x = 2&quot;.parse[Stat].get
    logger.elem(tree.syntax)
    logger.elem(tree.structure)
  }

}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/scalameta/scalameta-tutorial/tree/master/library/src/test/scala/scalaworld/Playground.scala#L0-L21" target="_blank"><i class="fa fa-link "></i></a></pre></li>
      <li>
        To test playground on every edit, run <code>sbt ~library/test</code>.</li>
      <li>
        Setup the project in your favorite IDE, for example IntelliJ, ENSIME or vim.
</li></ol>
  <h1 id="AmmoniteREPL" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#AmmoniteREPL" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Ammonite REPL</h1>
    To experiment with Scalameta in the REPL, you can run the following
    in the <a href="http://www.lihaoyi.com/Ammonite/#Ammonite-REPL">Ammonite REPL</a>
    <pre><code class="scala scalatex-site-Styles-highlightMe">import $ivy.`org.scalameta:scalameta_2.11:2.1.2`, scala.meta._</code></pre>
    <b>Note.</b> The macro annotation examples will not run in the REPL, follow
    <a href="https://github.com/scalameta/paradise/issues/10">scalameta/paradise#10</a>
    for updates.

  <h1 id="Video" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Video" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Video</h1>
    <p>
      To accompany the workshop, here is the recording from the original
      scala.world conference talk.</p>
    
      <iframe width="100%" style="height: 28em" src="https://www.youtube.com/embed/-l7pV0sFq1c" frameborder="0" allowfullscreen></iframe>

  

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Tokens" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Tokens<a class=" scalatex-site-Styles-headerLink" href="#Tokens" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
  <p>
    Make sure you have Scalameta installed as a library from <a href="#Setup">Setup</a>.

    You can decide to run these examples from the console or from sbt,
    for example in the tutorial repo.
</p>
  <p>
    This whole workshop will assume you have this import in scope:
</p>
  <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; import scala.meta._
import scala.meta._</code></pre>
  <p>
    Here's how to tokenize a small expression.

    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;val x = 2&quot;.tokenize.get
res0: scala.meta.tokens.Tokens = Tokens(, val,  , x,  , =,  , 2, )</code></pre>
    Let's discuss the most interesting methods on tokens.

    <h1 id="Tokens.syntax" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Tokens.syntax" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Tokens.syntax</h1>
      <p>
        The simplest method we can call is <code>Tokens.syntax</code>
        The method returns a string representation of the actual code behind
        the tokens, or how the code should look like to a developer.
</p>
      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;val x = 2&quot;.tokenize.get.syntax
res0: String = val x = 2</code></pre>
      <p>
        <code>Tokens.toString()</code> uses <code>.syntax</code> behind the scenes.
        However, you should never rely on <code>toString()</code> when manipulating
        Scalameta structures, prefer to explicitly call <code>.syntax</code>.
        It's maybe not so obvious why right now but it will make more sense soon.
</p>
    <h1 id="Tokens.structure" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Tokens.structure" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Tokens.structure</h1>
      <p>
        Another useful method is <code>Tokens.structure</code>.
        The method shows details that may be relevant to us as metaprogrammers.

        <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;val x = 2&quot;.tokenize.get.structure
res0: String = Tokens(BOF [0..0), val [0..3),   [3..4), x [4..5),   [5..6), = [6..7),   [7..8), 2 [8..9), EOF [9..9))</code></pre></p>
      <p>
        <code>.structure</code> is often useful for debugging and testing.
</p>
    <h1 id="Tokensvs.Token" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Tokensvs.Token" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Tokens vs. Token</h1>
      <p>
        The class <code>Tokens</code> is a wrapper around a sequence of <code>Token</code> objects.
        There are multiple subtypes of <code>Token</code> while there only one type <code>Tokens</code>.

        <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;val x = 2&quot;.tokenize.get.head
res0: scala.meta.tokens.Token =</code></pre></p>
       <code>BOF</code> stands for &quot;Beginning of file&quot;.
       Let's see what other kinds of token types are in the string

        <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;val x = 2&quot;.tokenize.get.
  map(x =&gt; f&quot;${x.structure}%10s -&gt; ${x.productPrefix}&quot;).
  mkString(&quot;\n&quot;)
res0: String =
BOF [0..0) -&gt; BOF
val [0..3) -&gt; KwVal
    [3..4) -&gt; Space
  x [4..5) -&gt; Ident
    [5..6) -&gt; Space
  = [6..7) -&gt; Equals
    [7..8) -&gt; Space
  2 [8..9) -&gt; Int
EOF [9..9) -&gt; EOF</code></pre>
        <p>
          Even spaces get their own tokens.
          The <code>[0...3)</code> part indicates that the <code>val</code> tokens start at
          offset 0 and ends at offset 3.
</p>
    <h1 id="==" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#==" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>==</h1>
      <p>
        How does token equality look like?
</p>
      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;foobar&quot;.tokenize.get(1) == &quot;foobar kas&quot;.tokenize.get(1)
res0: Boolean = false</code></pre>
      Huh, why are they not the same?

      <div class="bs-callout bs-callout-warning"><p>
        Token equality is implemented with reference equality.
        You need to be explicit if you actually mean syntactic (<code>.syntax</code>),
        or structural (<code>.structure</code>) equality.
</p></div>
      The tokens are syntactically equal.

      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;foobar&quot;.tokenize.get(1).syntax == &quot;foobar kas&quot;.tokenize.get(1).syntax
res0: Boolean = true</code></pre>
      Even if we move the tokens around

      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;kas foobar&quot;.tokenize.get(3).syntax == &quot;foobar kas&quot;.tokenize.get(1).syntax
res0: Boolean = true</code></pre>
      The tokens are also structurally equal.

      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;foobar&quot;.tokenize.get(1).structure == &quot;foobar kas&quot;.tokenize.get(1).structure
res0: Boolean = true</code></pre>
      However, they are not structurally equal if we move them around.

      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;kas foobar&quot;.tokenize.get(3).structure == &quot;foobar kas&quot;.tokenize.get(1).structure
res0: Boolean = false</code></pre>
    <h1 id=".get" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#.get" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>.get</h1>
      <p>
        Tokenization can sometimes fail, for example in this case:

        <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;&quot;&quot; val str = &quot;unclosed literal &quot;&quot;&quot;.tokenize
res0: scala.meta.tokenizers.Tokenized =
&lt;input&gt;:1: error: unclosed string literal
val str = &quot;unclosed literal
           ^</code></pre>
        <p>
          If you prefer, you can safely pattern match on the tokenize result

          <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;&quot;&quot; val str = &quot;closed literal&quot; &quot;&quot;&quot;.tokenize match {
  case tokenizers.Tokenized.Success(tokenized) =&gt; tokenized
  case tokenizers.Tokenized.Error(e, _, _) =&gt; ???
}
res0: scala.meta.tokens.Tokens = Tokens(,  , val,  , str,  , =,  , &quot;closed literal&quot;,  , )</code></pre></p></p></p>
  <h1 id="Conclusion" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Conclusion" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Conclusion</h1>
    <p>
      Scalameta tokens are the foundation of Scalameta.
      Sometimes you don't have access to a parsed AST and then your best shot is
      work with tokens.
</p>
    <p>
      In the following chapter we will discuss another exciting data structure:
      the incredible <b>scala.meta.Tree</b>.</p>

  

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Trees" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Trees<a class=" scalatex-site-Styles-headerLink" href="#Trees" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
  <p>
    Reminder. We assume you have this import in scope:
</p>
  <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; import scala.meta._
import scala.meta._</code></pre>
  <h1 id="q&quot;Quasiquotes&quot;" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#q&quot;Quasiquotes&quot;" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>q&quot;Quasiquotes&quot;</h1>
    <p>
      The easiest way to get started with Scalameta trees is using quasiquotes.
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; q&quot;case class User(name: String, age: Int)&quot;
res0: meta.Defn.Class = case class User(name: String, age: Int)</code></pre>
    <p>
      Quasiquotes can be composed
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; val method = q&quot;def `is a baby` = age &lt; 1&quot;
method: meta.Defn.Def = def `is a baby` = age &lt; 1

scala&gt; q&quot;&quot;&quot;
case class User(name: String, age: Int) {
  $method
}
&quot;&quot;&quot;
res0: meta.Defn.Class = case class User(name: String, age: Int) { def `is a baby` = age &lt; 1 }</code></pre>
    <p>
      Quasiquotes can also be used to deconstruct trees with pattern matching
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; q&quot;def `is a baby` = age &lt; 1&quot; match {
  case q&quot;def $name = $body&quot; =&gt;
    s&quot;You ${name.syntax} if your ${body.syntax}&quot;
}
res0: String = You `is a baby` if your age &lt; 1</code></pre>
    <div class="bs-callout bs-callout-warning"><p>
      <b>NOTE</b>. Quasiquotes currently ignore comments:

      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; q&quot;val x = 2 // assignment&quot;.syntax
res0: String = val x = 2</code></pre>
      If you need comments, you can use <a href="#.parse[T]">.parse[T]</a>

      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;val x = 2 // assignment&quot;.parse[Stat].get.syntax
res0: String = val x = 2 // assignment</code></pre></p></div>
  <h1 id=".parse[T]" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#.parse[T]" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>.parse[T]</h1>
    <p>
      If the contents that you want to parse are only known at runtime,
      you can't use quasiquotes.
      For example, this happens when you need to parse file contents.
</p>
    <p>
      Here's how to parse a compilation unit.
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;object Main extends App { println(1) }&quot;.parse[Source].get
res0: scala.meta.Source = object Main extends App { println(1) }</code></pre>
    <div class="bs-callout bs-callout-success"><p>
      Pro tip. You can also call <code>.parse[T]</code> on a <code>File</code>,
      just like this

      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; new java.io.File(&quot;readme/ParseMe.scala&quot;).parse[Source]
res0: scala.meta.parsers.Parsed[scala.meta.Source] =
class ParseMe { println(&quot;I'm inside a file&quot;) }</code></pre></p></div>
    <p>
      If we try to parse a statement as a compilation unit we will fail.
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;val x = 2&quot;.parse[Source]
res0: scala.meta.parsers.Parsed[scala.meta.Source] =
&lt;input&gt;:1: error: expected class or object definition
val x = 2
^</code></pre>
    <p>
      We need to explicitly parse it as a statement (<code>Stat</code>).
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;val x = 2&quot;.parse[Stat].get
res0: scala.meta.Stat = val x = 2</code></pre>
    <p>
      We can also parse case statement
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;case Foo(bar) if bar &gt; 2 =&gt; println(bar)&quot;.parse[Case].get
res0: scala.meta.Case = case Foo(bar) if bar &gt; 2 =&gt; println(bar)</code></pre>
    <p>
      Scalameta has dozens of parsers:
      <div class="text-center"><img style="width: 100%" src="img/parse.png" /><p></p></div>
      However, <code>.parse[Stat]</code> and <code>.parse[Source]</code> are
      usually all you need.
</p>
  <h1 id="dialects" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#dialects" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>dialects</h1>
    <p>
      I didn't tell the whole story when I said you need to pass in a type
      argument to parse statements.
      You also need to pass in a dialect!
      However, Scalameta will by default pick the <code>Scala211</code> dialect
      for you if you don't provide one explicitly.
</p>
    <p>
      With the SBT dialects, we can parse vals as top-level statements.
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; dialects.Sbt0137(
  &quot;lazy val core = project.settings(commonSettings)&quot;
).parse[Source].get
res0: scala.meta.Source = lazy val core = project.settings(commonSettings)</code></pre>
    <p>
      We can even parse multiple top level statements
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; dialects.Sbt0137(
  &quot;&quot;&quot;
  lazy val core = project.settings(commonSettings)

  lazy val extra = project.dependsOn(core)
  &quot;&quot;&quot;
).parse[Source].get
res0: scala.meta.Source =

  lazy val core = project.settings(commonSettings)

  lazy val extra = project.dependsOn(core)</code></pre>
    <p>
      For the remainder of the workshop, we will only work with the <code>Scala211</code>
      dialect.
</p>
  <h1 id="Tree.syntax" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Tree.syntax" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Tree.syntax</h1>
    <p>
      Just like with tokens, we can also run <code>.syntax</code> on trees.
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;foo(bar)&quot;.parse[Stat].get.syntax
res0: String = foo(bar)</code></pre>
    However, Scalameta can also do this even if you manually construct the tree

    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; Term.Apply(
  Term.Name(&quot;foo&quot;),
  Term.Name(&quot;bar&quot;) :: Nil
).syntax
res0: String = foo(bar)</code></pre>
    <p>
      We never gave Scalameta parentheses but still it figured out we needed
      them.
      Pretty cool huh.
</p>
  <h1 id="Tree.structure" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Tree.structure" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Tree.structure</h1>
    <p>
      Just like with tokens, we can also run <code>.structure</code> on trees.
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;foo(bar)&quot;.parse[Stat].get.structure
res0: String = Term.Apply(Term.Name(&quot;foo&quot;), List(Term.Name(&quot;bar&quot;)))</code></pre>
    <p>
      <code>.structure</code> ignores any syntactic trivia like whitespace and comments
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;foo  ( /* this is a comment */ bar  ) // eol&quot;.parse[Stat].get.structure
res0: String = Term.Apply(Term.Name(&quot;foo&quot;), List(Term.Name(&quot;bar&quot;)))</code></pre>
    <p>
      This can be useful for example in debugging, testing or equality checking.
</p>
  <h1 id="Tree.collect" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Tree.collect" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Tree.collect</h1>
    <p>
      You can collect on Scalameta.Tree just like regular collections.
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; source&quot;&quot;&quot;sealed trait Op[A]
    object Op extends B {
      case class Foo(i: Int) extends Op[Int]
      case class Bar(s: String) extends Op[String]
    }&quot;&quot;&quot;.collect { case cls: Defn.Class =&gt; cls.name }
res0: List[meta.Type.Name] = List(Foo, Bar)</code></pre>
  <h1 id="Tree.transform" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Tree.transform" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Tree.transform</h1>
    <p>
      Transform Scalameta.Tree with <code>.transform</code>.
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; q&quot;myList.filter(_ &gt; 3 + a).headOption // comments are removed :(&quot;.transform {
  case q&quot;$lst.filter($cond).headOption&quot; =&gt; q&quot;$lst.find($cond)&quot;
}
res0: scala.meta.Tree = myList.find(_ &gt; 3 + a)</code></pre>
    <div class="bs-callout bs-callout-warning"><p>
      <code>.transform</code> does not preserve syntactic details such as comments
      and formatting. There has been made some work on source aware transformation,
      see <a href="https://github.com/scalameta/scalameta/pull/457">#457</a>,
      but it still requires a bit more work.
</p></div>
  <h1 id="Tree.==" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Tree.==" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Tree.==</h1>
    <p>
      Just like with tokens, tree equality is by default by reference:
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; q&quot;foo(bar)&quot; == q&quot;foo(bar)&quot;
res0: Boolean = false</code></pre>
    This means you need to be explicit if you mean syntactic equality

    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; q&quot;foo(bar)&quot;.syntax == q&quot;foo(bar)&quot;.syntax
res0: Boolean = true</code></pre>
    <p>
      or structural equality
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; q&quot;foo(bar)&quot;.structure == q&quot;foo(bar)&quot;.structure
res0: Boolean = true</code></pre>
  <h1 id="Comprehensivetrees" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Comprehensivetrees" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Comprehensive trees</h1>
    <p>
      A key feature of Scalameta trees is that they comprehensively cover
      all corners of the Scala syntax.
      A side effect of this is that the Scalameta tree hierarchy contains a
      lot of types.
      For example, there is a different tree node for an abstract <code>def</code> (<code>Decl.Def</code>)

      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; q&quot;def add(a: Int, b: Int)&quot; // Decl.Def
res0: meta.Decl.Def = def add(a: Int, b: Int): Unit</code></pre>
      and a <code>def</code> with an implementation (<code>Defn.Def</code>)

      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; q&quot;def add(a: Int, b: Int) = a + b&quot; // Defn.Def
res0: meta.Defn.Def = def add(a: Int, b: Int) = a + b</code></pre>
      <p>
        Fortunately, most of the time you won't need to worry about this.
        Quasiquotes help you create/match/compose/deconstruct the correct instances.
        However, occasionally you may need to debug the types of the trees you have.
</p>
      <p>
        For your convenience, I've compiled together the most common types in
        this handy diagram:
        <div class="text-center"><img style="width: 100%" src="img/tree.png" /><p></p></div></p></p>

  

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Macroannotations" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Macro annotations<a class=" scalatex-site-Styles-headerLink" href="#Macroannotations" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
  <p>
    This section has now moved to <a href="../paradise">scalameta/paradise</a>.</p>

  

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="SemanticAPI" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Semantic API<a class=" scalatex-site-Styles-headerLink" href="#SemanticAPI" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
  The semantic API offers operations to query information from the Scala compiler
  such as name resolution (<code>println</code> =&gt; <code>_root_.scala.Predef.println</code>),
  symbol signatures (<code>_root_.com.Example.main([Ljava/lang/String;)V.</code> =&gt;
  <code>def main(args: Array[String]): Unit</code>),
  These operations can for example be used by tools like
  <a href="https://scalacenter.github.io/scalafix">scalafix</a> to rewrite Scala source code.
  The semantic API cannot be used from <a href="#Macroannotations">Macro annotations</a>.

  <h1 id="SemanticDB" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#SemanticDB" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>SemanticDB</h1>
    <p>
      A key property of the Scalameta semantic API is its <b>portability</b>.
      &quot;SemanticDB&quot; is the storage format for information that
      the semantic API consumes.
</p>
    <p>
      Currently, a typical approach to semantic developer tools in Scala is
      implementing them as compiler plugins and then using them inside builds.
      Apart from being a hassle to configure, this approach is also quite slow,
      because it needs to run a Scala typechecker every time when a tool is
      invoked.
</p>
    <p>
      Scalameta enables a much more convenient workflow. First, we use our
      semanticdb-scalac compiler plugin to generate a semantic database for it
      during type checking.
      This is done only once per unique snapshot of the codebase.
      Afterwards, using the persisted semantic data, we can launch
      any number of developer tools any number of times without having to
      typecheck the codebase again.
</p>
    <p>
      The storage format used for the SemanticDB is defined using
      <a href="https://www.google.ch/search?q=protocol+buffers&amp;oq=protocol+buffer&amp;aqs=chrome.0.0j69i61j69i57j69i61j0l2.6856j0j7&amp;sourceid=chrome&amp;ie=UTF-8">Protocol Buffers</a>,
      or &quot;protobuf&quot; for short.  The SemanticDB protobuf schema is small, at
      the time of this writing it is ~50 lines of code.  The full schema is
      available
      <a href="https://github.com/scalameta/scalameta/blob/master/langmeta/shared/src/main/protobuf/semanticdb.proto">here</a>.
      Files containing SemanticDB binary data use the <code>.semanticdb</code> file
      extension by convention.
</p>
  <h1 id="semanticdb-scalac" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#semanticdb-scalac" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>semanticdb-scalac</h1>
    To build a <a href="#SemanticDB">SemanticDB</a> with the Scala 2.x compiler, you will need
    the semanticdb-scalac compiler plugin.
    This compiler plugin is developed in the main Scalameta repository.
    There are several ways to <a href="#Installation">install</a> semanticdb-scalac
    into your build.

    <h2 id="Installation" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Installation" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Installation</h2>
      The required setup for the Semantic API is more involved than for the
      Syntactic API (parsing/tokenizing).
      Most importantly, we first need to compile source files with the Scala compiler
      and semanticdb-scalac compiler plugin in order to collect information such as types,
      symbols and more. While it's possible to tokenize or parse code that
      doesn't compile, a source file must successfully typecheck in order for it
      to be analyzed with the Semantic API.

      

<h3 id="sbt-semantic-example" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#sbt-semantic-example" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>sbt-semantic-example</h3>
  For a plug and play example repository, clone
  <a href="https://github.com/scalameta/sbt-semantic-example">sbt-semantic-example</a>
  and run <code>sbt app/run</code>

<h3 id="sbt" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#sbt" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>sbt</h3>
  <pre><code class="scala scalatex-site-Styles-highlightMe">lazy val semanticdb-scalacSettings = Seq(
  addCompilerPlugin(&quot;org.scalameta&quot; % &quot;semanticdb-scalac&quot; % &quot;2.1.2&quot; cross CrossVersion.full),
  scalacOptions ++= Seq(
    &quot;-Yrangepos&quot;,
    &quot;-Xplugin-require:semanticdb&quot;
  )
)
</code></pre>
  Add the following settings your project like this

  <pre><code class="scala scalatex-site-Styles-highlightMe">lazy val analyzeMe = project.settings(
  // semanticdb-scalac supports the Scala versions: 2.11.12, 2.12.4.
  // Note, the Scala version must match down to the latest (PATCH) number.
  scalaVersion := &quot;2.12.4&quot;,
  semanticdb-scalacVersions
)
</code></pre>
<h3 id="Otherbuildtools" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Otherbuildtools" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Other build tools</h3>
  You can use semanticdb-scalac outside of sbt by passing in custom scalac flags.
  <pre><code class="scala scalatex-site-Styles-highlightMe">// -Xplugin-require:semanticdb-scalac tells scalac to fail fast if semanticdb-scalac failed to load
// -Yrangepos is required by semanticdb-scalac
scalac -Xplugin:/path/to/semanticdb-scalac.jar -Yrangepos -Xplugin-require:semanticdb-scalac Code.scala
</code></pre>
<h3 id="scalameta/tutorialsemantic/run" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#scalameta/tutorialsemantic/run" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>scalameta/tutorial semantic/run</h3>
  If you have cloned the repo for this tutorial as explained in
  <a href="#Tutorial">Tutorial</a>, you can execute <code>sbt semantic/run</code> to run
  an example application using the semantic API.

<h3 id="Coursier" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Coursier" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Coursier</h3>
  If you have <a href="https://github.com/coursier/coursier">coursier</a> installed,
  you can run this one-liner assuming you want to analyze a source file <code>Foo.scala</code>

  <pre><code class="scala scalatex-site-Styles-highlightMe">// make sure the version of scalac is 2.12.4
scalac -Yrangepos -Xplugin-require:semanticdb-scalac -Xplugin:$(coursier fetch --intransitive org.scalameta:semanticdb-scalac_2.12.4:1.8.0) Foo.scala

</code></pre>
<h3 id="Verifyinstallation" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Verifyinstallation" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Verify installation</h3>
  To verify that the semanticdb-scalac compiler plugin is installed
  <ul>
    <li>
      make sure that you are compiling least one source file</li>
    <li>
      clean</li>
    <li>
      compile</li>
    <li>
      look into the target/ directory for files with the file extension <code>.semanticdb</code>.
      The files will appear under a directory called <code>META-INF/semanticdb</code>.
</li></ul>
  If you cannot find any <code>.semanticdb</code> files, then something went wrong with the setup.
  Don't hesitate to ask questions on <a href="https://gitter.im/scalameta/scalameta?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge"><img src="https://camo.githubusercontent.com/da2edb525cde1455a622c58c0effc3a90b9a181c/68747470733a2f2f6261646765732e6769747465722e696d2f4a6f696e253230436861742e737667" alt="Join the chat at https://gitter.im/scalameta/scalameta" data-canonical-src="https://badges.gitter.im/Join%20Chat.svg" style="max-width:100%;"></a>.


  <h1 id="semanticdb-sbt" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#semanticdb-sbt" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>semanticdb-sbt</h1>
    It's possible to build a SemanticDB for <code>.sbt</code> and <code>.scala</code>
    sources of sbt 0.13 builds.
    For more details, see
    <a href="https://scalacenter.github.io/scalafix/#semanticdb-sbt">scalafix/semanticdb-sbt</a>.

  <h1 id="Example" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Example" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Example</h1>

    <p>
      Let's take a look at the inside of a <code>.semanticdb</code> file.
      Given a source file <code>Input.scala</code>
</p>
    <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">package scalaworld.semantic

case class Input(x: Int) {
  def +(other: Input) = Input(x + other.x)
  def +(other: Int) = Input(x + other)
  1 + 2
  List(x).map(num =&gt; Input(num + 1) + Input(2) + 3)
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/scalameta/scalameta-tutorial/tree/master/semantic/input/src/main/scala/scalaworld/semantic/Input.scala#L0-L8" target="_blank"><i class="fa fa-link "></i></a></pre>

    <p>
      the pretty printed representation of its corresponding <code>Input.semanticdb</code>
      is the following:
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">semantic/input/src/main/scala/scalaworld/semantic/Input.scala
-------------------------------------------------------------
Language:
Scala212

Names:
[8..18): scalaworld =&gt; _root_.scalaworld.
[19..27): semantic =&gt; _root_.scalaworld.semantic.
[40..45): Input &lt;= _root_.scalaworld.semantic.Input#
[45..45): ε &lt;= _root_.scalaworld.semantic.Input#`&lt;init&gt;`(I)V.
[46..47): x &lt;= _root_.scalaworld.semantic.Input#(x)
[49..52): Int =&gt; _root_.scala.Int#
[62..63): + &lt;= _root_.scalaworld.semantic.Input#`+`(Lscalaworld/semantic/Input;)Lscalaworld/semantic/Input;.
[64..69): other &lt;= _root_.scalaworld.semantic.Input#`+`(Lscalaworld/semantic/Input;)Lscalaworld/semantic/Input;.(other)
[71..76): Input =&gt; _root_.scalaworld.semantic.Input#
[80..85): Input =&gt; _root_.scalaworld.semantic.Input.
[86..87): x =&gt; _root_.scalaworld.semantic.Input#(x)
[88..89): + =&gt; _root_.scala.Int#`+`(I)I.
[90..95): other =&gt; _root_.scalaworld.semantic.Input#`+`(Lscalaworld/semantic/Input;)Lscalaworld/semantic/Input;.(other)
[96..97): x =&gt; _root_.scalaworld.semantic.Input#(x)
[105..106): + &lt;= _root_.scalaworld.semantic.Input#`+`(I)Lscalaworld/semantic/Input;.
[107..112): other &lt;= _root_.scalaworld.semantic.Input#`+`(I)Lscalaworld/semantic/Input;.(other)
[114..117): Int =&gt; _root_.scala.Int#
[121..126): Input =&gt; _root_.scalaworld.semantic.Input.
[127..128): x =&gt; _root_.scalaworld.semantic.Input#(x)
[129..130): + =&gt; _root_.scala.Int#`+`(I)I.
[131..136): other =&gt; _root_.scalaworld.semantic.Input#`+`(I)Lscalaworld/semantic/Input;.(other)
[142..143): + =&gt; _root_.scala.Int#`+`(I)I.
[148..152): List =&gt; _root_.scala.collection.immutable.List.
[153..154): x =&gt; _root_.scalaworld.semantic.Input#(x)
[156..159): map =&gt; _root_.scala.collection.immutable.List#map(Lscala/Function1;Lscala/collection/generic/CanBuildFrom;)Ljava/lang/Object;.
[160..163): num &lt;= semantic/input/src/main/scala/scalaworld/semantic/Input.scala@160..163
[167..172): Input =&gt; _root_.scalaworld.semantic.Input.
[173..176): num =&gt; semantic/input/src/main/scala/scalaworld/semantic/Input.scala@160..163
[177..178): + =&gt; _root_.scala.Int#`+`(I)I.
[182..183): + =&gt; _root_.scalaworld.semantic.Input#`+`(Lscalaworld/semantic/Input;)Lscalaworld/semantic/Input;.
[184..189): Input =&gt; _root_.scalaworld.semantic.Input.
[193..194): + =&gt; _root_.scalaworld.semantic.Input#`+`(I)Lscalaworld/semantic/Input;.

Messages:
[140..145): [warning] a pure expression does nothing in statement position; multiline expressions may require enclosing parentheses

Symbols:
_root_.scala.Int# =&gt; abstract final class Int
_root_.scala.Int#`+`(I)I. =&gt; abstract def +: (x: Int): Int
  [4..7): Int =&gt; _root_.scala.Int#
  [10..13): Int =&gt; _root_.scala.Int#
_root_.scala.Int#`&lt;init&gt;`()V. =&gt; primaryctor &lt;init&gt;: (): Int
  [4..7): Int =&gt; _root_.scala.Int#
_root_.scala.collection.immutable.List#map(Lscala/Function1;Lscala/collection/generic/CanBuildFrom;)Ljava/lang/Object;. =&gt; final def map: [B, That] =&gt; (f: Function1[A, B])(implicit bf: CanBuildFrom[List[A], B, That]): That
  [17..26): Function1 =&gt; _root_.scala.Function1#
  [27..28): A =&gt; _root_.scala.collection.immutable.List#[A]
  [30..31): B =&gt; _root_.scala.collection.immutable.List#map(Lscala/Function1;Lscala/collection/generic/CanBuildFrom;)Ljava/lang/Object;.[B]
  [47..59): CanBuildFrom =&gt; _root_.scala.collection.generic.CanBuildFrom#
  [60..64): List =&gt; _root_.scala.collection.immutable.List#
  [65..66): A =&gt; _root_.scala.collection.immutable.List#[A]
  [69..70): B =&gt; _root_.scala.collection.immutable.List#map(Lscala/Function1;Lscala/collection/generic/CanBuildFrom;)Ljava/lang/Object;.[B]
  [72..76): That =&gt; _root_.scala.collection.immutable.List#map(Lscala/Function1;Lscala/collection/generic/CanBuildFrom;)Ljava/lang/Object;.[That]
  [80..84): That =&gt; _root_.scala.collection.immutable.List#map(Lscala/Function1;Lscala/collection/generic/CanBuildFrom;)Ljava/lang/Object;.[That]
_root_.scala.collection.immutable.List. =&gt; final object List
_root_.scalaworld. =&gt; package scalaworld
_root_.scalaworld.semantic. =&gt; package semantic
_root_.scalaworld.semantic.Input# =&gt; case class Input
_root_.scalaworld.semantic.Input#(x) =&gt; val param x: Int
  [0..3): Int =&gt; _root_.scala.Int#
_root_.scalaworld.semantic.Input#`+`(I)Lscalaworld/semantic/Input;. =&gt; def +: (other: Int): Input
  [8..11): Int =&gt; _root_.scala.Int#
  [14..19): Input =&gt; _root_.scalaworld.semantic.Input#
_root_.scalaworld.semantic.Input#`+`(I)Lscalaworld/semantic/Input;.(other) =&gt; param other: Int
  [0..3): Int =&gt; _root_.scala.Int#
_root_.scalaworld.semantic.Input#`+`(Lscalaworld/semantic/Input;)Lscalaworld/semantic/Input;. =&gt; def +: (other: Input): Input
  [8..13): Input =&gt; _root_.scalaworld.semantic.Input#
  [16..21): Input =&gt; _root_.scalaworld.semantic.Input#
_root_.scalaworld.semantic.Input#`+`(Lscalaworld/semantic/Input;)Lscalaworld/semantic/Input;.(other) =&gt; param other: Input
  [0..5): Input =&gt; _root_.scalaworld.semantic.Input#
_root_.scalaworld.semantic.Input#`&lt;init&gt;`(I)V. =&gt; primaryctor &lt;init&gt;: (x: Int): Input
  [4..7): Int =&gt; _root_.scala.Int#
  [10..15): Input =&gt; _root_.scalaworld.semantic.Input#
_root_.scalaworld.semantic.Input. =&gt; final object Input
semantic/input/src/main/scala/scalaworld/semantic/Input.scala@160..163 =&gt; param num: Int
  [0..3): Int =&gt; _root_.scala.Int#

Synthetics:
[85..85): *.apply
  [0..1): * =&gt; _star_.
  [2..7): apply =&gt; _root_.scalaworld.semantic.Input.apply(I)Lscalaworld/semantic/Input;.
[126..126): *.apply
  [0..1): * =&gt; _star_.
  [2..7): apply =&gt; _root_.scalaworld.semantic.Input.apply(I)Lscalaworld/semantic/Input;.
[152..152): *.apply[Int]
  [0..1): * =&gt; _star_.
  [2..7): apply =&gt; _root_.scala.collection.immutable.List.apply(Lscala/collection/Seq;)Lscala/collection/immutable/List;.
  [8..11): Int =&gt; _root_.scala.Int#
[159..159): *[Input, List[Input]]
  [0..1): * =&gt; _star_.
  [2..7): Input =&gt; _root_.scalaworld.semantic.Input#
  [9..13): List =&gt; _root_.scala.collection.immutable.List#
  [14..19): Input =&gt; _root_.scalaworld.semantic.Input#
[172..172): *.apply
  [0..1): * =&gt; _star_.
  [2..7): apply =&gt; _root_.scalaworld.semantic.Input.apply(I)Lscalaworld/semantic/Input;.
[189..189): *.apply
  [0..1): * =&gt; _star_.
  [2..7): apply =&gt; _root_.scalaworld.semantic.Input.apply(I)Lscalaworld/semantic/Input;.
[197..197): *(scala.collection.immutable.List.canBuildFrom[Input])
  [0..1): * =&gt; _star_.
  [47..52): Input =&gt; _root_.scalaworld.semantic.Input#
  [34..46): canBuildFrom =&gt; _root_.scala.collection.immutable.List.canBuildFrom()Lscala/collection/generic/CanBuildFrom;.
</code></pre>

    <p>
      That is a lot of output, let's take a closer look at each of
      the sections:
      <a href="#Names">Names</a>,
      <a href="#Messages">Messages</a>,
      <a href="#Denotations">Denotations</a>, and
      <a href="#Sugars">Sugars</a>.
</p>
  <h1 id="Reference" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Reference" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Reference</h1>
    <p>
      Below are explanations of the terminology used in SemanticDB.</p>
    

<h2 id="Names" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Names" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Names</h2>
  <p>
    The <code>Names</code> section is a map from names/identifiers to the <a href="#Symbol">Symbol</a> they reference.
    A name is an identifier such as <code>List</code> or <code>+</code>.
    A name can have different symbols depending on where the name appears.
    For example, <code>+</code> references three different symbols in the example above
    <pre><code class="scala scalatex-site-Styles-highlightMe">// Int + Int
[88..89): +   =&gt; _root_.scala.Int#`+`(I)I.
// Bar + Bar
[62..63): +   =&gt; _root_.scalaworld.semantic.Input#`+`(Lscalaworld/semantic/Input;)Lscalaworld/semantic/Input;.
// Bar + Int
[105..106): + =&gt; _root_.scalaworld.semantic.Input#`+`(I)Lscalaworld/semantic/Input;.
</code></pre></p>
<h2 id="Denotations" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Denotations" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Denotations</h2>
  The <code>Denotations</code> section is a map from <a href="#Symbol">Symbol</a>s that appear
  in the source file to the <a href="#Denotation">Denotation</a> of the symbol.

<h2 id="Messages" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Messages" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Messages</h2>
  The <code>Messages</code> section is a list of the reporter compiler messages (info/warn/error).
  Note, some reported messages like deprecation warnings are not yet collected, see <a href="http://scalameta.org/tutorial/issues/759">#759</a>.

<h2 id="Synthetics" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Synthetics" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Synthetics</h2>
  The <code>Synthetics</code> section lists the code that is inserted/inferred by the compiler.
  Syntehtics don't appear in the original source file.
  Synthetics include inferred type parameters, type annotations of definitions,
  implicit arguments and more.
  It is possible to resolve symbols of synthetics, just like with regular names
  that appear in the source file.

<h2 id="Symbol" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Symbol" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Symbol</h2>
  Every definition such as a class/trait/val/var/def/object has a unique identifier.
  This unique identifier is called a <code>Symbol</code>.
  By convention, <a href="#semanticdb-scalac">semanticdb-scalac</a> uses the the erased JVM signature of the definition
  to represent a Scala symbol .
  This makes it possible to distinguish between overloaded methods.
  A symbol is an opaque identifier, to understand the signature
  of a symbol inspect its <a href="#Denotation">Denotation</a>.

<h2 id="Denotation" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Denotation" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Denotation</h2>
  A denotation represents a <a href="#Symbol">Symbol</a>'s &quot;meaning&quot;, including modifiers,
  visibility restrictions and type signature.
  A denotation can for example tell you if a definition is a trait or a class,
  if it has the <code>implicit</code> modifier or what it's return type is.

<h2 id="Scalahost" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Scalahost" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Scalahost</h2>
  &quot;Scalahost&quot; is the old name for <a href="#semanticdb-scalac">semanticdb-scalac</a>.

<h2 id="Sugars" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Sugars" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Sugars</h2>
  &quot;Sugars&quot; is the old name for <a href="#Synthetics">Synthetics</a>.



  

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Contrib" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Contrib<a class=" scalatex-site-Styles-headerLink" href="#Contrib" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
  Scalameta contrib is a module that provides common utilities for handling
  Scalameta data structures.

  <p>
    To use contrib, <code>import scala.meta.contrib._</code>.
</p>
  <p>
    Contrib exposes some collection-like methods on <code>Tree</code>.
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; source&quot;&quot;&quot;
class A
trait B
object C
object D
&quot;&quot;&quot;.find(_.is[Defn.Object])
res0: Option[scala.meta.Tree] = Some(object C)

scala&gt; source&quot;&quot;&quot;
class A
trait B
object C {
  val x = 2
  val y = 3
}
object D
&quot;&quot;&quot;.collectFirst { case q&quot;val y = $body&quot; =&gt;  body.structure }
res1: Option[String] = Some(Lit.Int(3))

scala&gt; source&quot;&quot;&quot;
class A
trait B
object C {
  val x = 2
  val y = 3
}
object D
&quot;&quot;&quot;.exists(_.is[Defn.Def])
res2: Boolean = false</code></pre></p>
  <p>
    Contrib has a <code>Equal</code> typeclass for comparing trees by structural or
    syntactic equality.
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; q&quot;val x = 2&quot;.isEqual(q&quot;val x = 1&quot;)
res0: Boolean = false

scala&gt; (q&quot;val x = 2&quot;: Stat).isEqual(&quot;val x = 2 // comment&quot;.parse[Stat].get)
res1: Boolean = true

scala&gt; (q&quot;val x = 2&quot;: Stat).isEqual[Syntactically](&quot;val x = 2 // comment&quot;.parse[Stat].get)
res2: Boolean = false

scala&gt; q&quot;lazy val x = 2&quot;.mods.exists(_.isEqual(mod&quot;lazy&quot;))
res3: Boolean = true

scala&gt; q&quot;lazy val x = 2&quot;.contains(q&quot;3&quot;)
res4: Boolean = false

scala&gt; q&quot;lazy val x = 2&quot;.contains(q&quot;2&quot;)
res5: Boolean = true</code></pre></p>
  <p>
    Contrib has an <code>AssociatedCommments</code> helper to extract leading
    and trailing comments of tree nodes.
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; val code: Source = &quot;&quot;&quot;
/** This is a docstring */
trait MyTrait // leading comment
&quot;&quot;&quot;.parse[Source].get
code: scala.meta.Source =

/** This is a docstring */
trait MyTrait // leading comment

scala&gt; val comments = AssociatedComments(code)
comments: scala.meta.contrib.AssociatedComments =
AssociatedComments(
  Leading =
    trait [28..33) =&gt; List(/**∙This∙is∙a∙docstring∙*/)

  Trailing =

)

scala&gt; val myTrait = code.find(_.is[Defn.Trait]).get
myTrait: scala.meta.Tree = trait MyTrait

scala&gt; comments.leading(myTrait) -&gt; comments.trailing(myTrait)
res0: (Set[meta.tokens.Token.Comment], Set[meta.tokens.Token.Comment]) = (Set(/** This is a docstring */),Set())</code></pre></p>

  

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="FAQ" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">FAQ<a class=" scalatex-site-Styles-headerLink" href="#FAQ" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
  <h1 id="Macros?" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Macros?" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Macros?</h1>
    Originally, Scalameta was founded to become a better macro system for Scala,
    but over time we shifted focus to developer tools and spun off the new macro system
    into a separate project: <a href="https://github.com/scalamacros/scalamacros">scalamacros/scalamacros</a>.
    See <a href="../paradise">scalameta/paradise</a> for more information about the deprecated scalameta macro annotations.

  <h1 id="WhatisthequasiquoteforX?" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#WhatisthequasiquoteforX?" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>What is the quasiquote for X?</h1>
    Here is an overview of quasiquote syntax: <a href="https://github.com/scalameta/scalameta/blob/master/notes/quasiquotes.md">https://github.com/scalameta/scalameta/blob/master/notes/quasiquotes.md</a>.

  <h1 id="CanIuseScalametawithScala.js?" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#CanIuseScalametawithScala.js?" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Can I use Scalameta with Scala.js?</h1>
    Yes, the main Scalameta modules support Scala.js.


  <h1 id="I'dliketousethesemanticapiasareplacementforscalac's
presentationcompiler,isthisdoable?intendedusage?" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#I'dliketousethesemanticapiasareplacementforscalac's
presentationcompiler,isthisdoable?intendedusage?" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>I'd like to use the semantic api as a replacement for scalac's
        presentation compiler, is this doable? intended usage?</h1>
    In principle, this should be doable, but it requires custom development
    and is not supported at the moment.

  <h1 id="HowdoIusetheSemanticAPI" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#HowdoIusetheSemanticAPI" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>How do I use the Semantic API</h1>
    See
    <ul>
      <li>
        <a href="#Installation">Installation</a></li>
      <li>
        <a href="https://github.com/scalameta/sbt-semantic-example">sbt-semantic-example</a></li>
      <li>
        <a href="https://scalacenter.github.io/scalafix/#scalacenter/scalafix.g8">scalacenter/scalafix.g8</a>
</li></ul>
  <h1 id="DoesScalametaintegratewithZincinordertoachievethesemanticapi?" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#DoesScalametaintegratewithZincinordertoachievethesemanticapi?" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Does Scalameta integrate with Zinc in order to achieve the semantic api?</h1>
    No, Zinc and Scalameta and unrelated.  The Scalameta Semantic
    API is enabled with the scalac compiler plugin <a href="#semanticdb-scalac">semanticdb-scalac</a>.
    semanticdb-scalac is designed to accommodate incremental compilation in order to
    play nicely with Zinc.

  <h1 id="WherecanIaskmorequestions?" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#WherecanIaskmorequestions?" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Where can I ask more questions?</h1>
    <ul>
      <li>
        use the
        <a href="http://stackoverflow.com/questions/tagged/scala-meta">scala-meta</a>.
        tag on Stack Overflow.</li>
      <li>
        We also have a Gitter channel
        
          <a href="https://gitter.im/scalameta/scalameta?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge"><img src="https://camo.githubusercontent.com/da2edb525cde1455a622c58c0effc3a90b9a181c/68747470733a2f2f6261646765732e6769747465722e696d2f4a6f696e253230436861742e737667" alt="Join the chat at https://gitter.im/scalameta/scalameta" data-canonical-src="https://badges.gitter.im/Join%20Chat.svg" style="max-width:100%;"></a>
</li></ul>

  


  <!-- Latest compiled and minified CSS -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <style>
    .bs-callout-danger {
      border-left-color: #ce4844 !IMPORTANT;
    }
    .bs-callout-danger h4 {
      color: #ce4844 !IMPORTANT;
    }
    .bs-callout-warning {
      border-left-color: #aa6708 !IMPORTANT;
    }
    .bs-callout-warning h4 {
      color: #aa6708 !IMPORTANT;
    }
    .bs-callout-info {
      border-left-color: #1b809e !IMPORTANT;
    }
    .bs-callout-info h4 {
      color: #1b809e !IMPORTANT;
    }
    .bs-callout-success {
      border-left-color: #5cb85c !IMPORTANT;
    }
    .bs-callout {
        padding: 20px;
        margin: 20px 0;
        border: 1px solid #eee;
        border-left-width: 5px;
        border-radius: 3px;
    }
    .scalatex-site-Styles-headerTag {
      margin-bottom: 20px !important;
    }
  </style>

</div>

  <script type="text/javascript">
    var _paq = _paq || [];
    _paq.push(["setDomains", ["*.scalameta.org"]]);
    _paq.push(['trackPageView']);
    _paq.push(['enableLinkTracking']);
    (function() {
      var u="https://stats.geirsson.com/hello/";
      _paq.push(['setTrackerUrl', u+'hello.php']);
      _paq.push(['setSiteId', 4]);
      var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
      g.type='text/javascript'; g.async=true; g.defer=true; g.src=u+'hello.js'; s.parentNode.insertBefore(g,s);
    })();
  </script>
  <noscript><p><img src="https://stats.geirsson.com/hello/hello.php?idsite=4" style="border:0;" alt="" /></p></noscript>
</div><script>
    scalatex.scrollspy.Controller().main(
      [{"value":"A Whirlwind Tour of Scalameta","children":[{"value":"Setup","children":[{"value":"Library","children":[]},{"value":"Tutorial","children":[]},{"value":"Ammonite REPL","children":[]},{"value":"Video","children":[]}]},{"value":"Tokens","children":[{"value":"Tokens.syntax","children":[]},{"value":"Tokens.structure","children":[]},{"value":"Tokens vs. Token","children":[]},{"value":"==","children":[]},{"value":".get","children":[]},{"value":"Conclusion","children":[]}]},{"value":"Trees","children":[{"value":"q\"Quasiquotes\"","children":[]},{"value":".parse[T]","children":[]},{"value":"dialects","children":[]},{"value":"Tree.syntax","children":[]},{"value":"Tree.structure","children":[]},{"value":"Tree.collect","children":[]},{"value":"Tree.transform","children":[]},{"value":"Tree.==","children":[]},{"value":"Comprehensive trees","children":[]}]},{"value":"Macro annotations","children":[]},{"value":"Semantic API","children":[{"value":"SemanticDB","children":[]},{"value":"semanticdb-scalac","children":[{"value":"Installation","children":[{"value":"sbt-semantic-example","children":[]},{"value":"sbt","children":[]},{"value":"Other build tools","children":[]},{"value":"scalameta/tutorial semantic/run","children":[]},{"value":"Coursier","children":[]},{"value":"Verify installation","children":[]}]}]},{"value":"semanticdb-sbt","children":[]},{"value":"Example","children":[]},{"value":"Reference","children":[{"value":"Names","children":[]},{"value":"Denotations","children":[]},{"value":"Messages","children":[]},{"value":"Synthetics","children":[]},{"value":"Symbol","children":[]},{"value":"Denotation","children":[]},{"value":"Scalahost","children":[]},{"value":"Sugars","children":[]}]}]},{"value":"Contrib","children":[]},{"value":"FAQ","children":[{"value":"Macros?","children":[]},{"value":"What is the quasiquote for X?","children":[]},{"value":"Can I use Scalameta with Scala.js?","children":[]},{"value":"I'd like to use the semantic api as a replacement for scalac's\n        presentation compiler, is this doable? intended usage?","children":[]},{"value":"How do I use the Semantic API","children":[]},{"value":"Does Scalameta integrate with Zinc in order to achieve the semantic api?","children":[]},{"value":"Where can I ask more questions?","children":[]}]}]}]
  )</script><script>
    ['DOMContentLoaded', 'load'].forEach(function(ev){
      addEventListener(ev, function(){
        Array.prototype.forEach.call(
          document.getElementsByClassName('scalatex-site-Styles-highlightMe'),
          hljs.highlightBlock
        );
      })
    })
  </script></body></html>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     