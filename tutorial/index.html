<!DOCTYPE html><html><head><link href="META-INF/resources/webjars/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" /><link href="styles.css" rel="stylesheet" /><link rel="shortcut icon" type="image/png" href="favicon.png" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><style>
.scalatex-site-Styles-headerLink{
  color: #777;
  opacity: 0.05;
  text-decoration: none;
}


.scalatex-site-Styles-hoverContainer:hover .scalatex-site-Styles-headerLink{
  color: #777;
  opacity: 0.5;
  text-decoration: none;
}
.scalatex-site-Styles-hoverContainer:hover .scalatex-site-Styles-headerLink:hover{
  opacity: 1.0;
}
.scalatex-site-Styles-hoverContainer:hover .scalatex-site-Styles-headerLink:active{
  opacity: 0.75;
}

.scalatex-site-Styles-content{
  color: #777;
  line-height: 1.6em;
  margin: 0 auto;
  margin-left: auto;
  margin-right: auto;
  max-width: 800px;
  padding: 0 1em;
  padding-bottom: 50px;
}
.scalatex-site-Styles-content *{
  position: relative;
}
.scalatex-site-Styles-content p{
  text-align: justify;
}
.scalatex-site-Styles-content a:link{
  color: #37a;
  text-decoration: none;
}
.scalatex-site-Styles-content a:visited{
  color: #949;
  text-decoration: none;
}
.scalatex-site-Styles-content a:hover{
  text-decoration: underline;
}
.scalatex-site-Styles-content a:active{
  color: #000;
  text-decoration: underline;
}
.scalatex-site-Styles-content code{
  color: #000;
}

/*Workaround for bug in highlight.js IDEA theme*/
span.hljs-tag, span.hljs-symbol{
    background: none;
}
    </style><title>A Whirlwind Tour of Scalameta</title><script src="scripts.js"></script></head><body><div>


  <a href="https://github.com/olafurpg/scala.meta-workshop"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/652c5b9acfaddf3a9c326fa6bde407b87f7be0f4/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6f72616e67655f6666373630302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png"></a>

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="AWhirlwindTourofScalameta" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">A Whirlwind Tour of Scalameta<a class=" scalatex-site-Styles-headerLink" href="#AWhirlwindTourofScalameta" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div><div class=" scalatex-site-Styles-content">
  <p>
    For any Scalameta related questions, don't hesitate to ask on our gitter channel:
    <a href="https://gitter.im/scalameta/scalameta?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge"><img src="https://camo.githubusercontent.com/da2edb525cde1455a622c58c0effc3a90b9a181c/68747470733a2f2f6261646765732e6769747465722e696d2f4a6f696e253230436861742e737667" alt="Join the chat at https://gitter.im/scalameta/scalameta" data-canonical-src="https://badges.gitter.im/Join%20Chat.svg" style="max-width:100%;"></a></p>
  

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Setup" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Setup<a class=" scalatex-site-Styles-headerLink" href="#Setup" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
  <h1 id="Library" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Library" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Library</h1>
    You can use Scalameta as a library, the <code>scalameta</code> umbrella package
    includes modules for trees, tokens, parsing, pretty printing, semantic API
    and more,
    <pre><code class="scala scalatex-site-Styles-highlightMe">libraryDependencies += &quot;org.scalameta&quot; %% &quot;scalameta&quot; % &quot;3.2.0&quot;
</code></pre>
    Optionally, for extra utilities, you can use <a href="#Contrib">Contrib</a>
    <pre><code class="scala scalatex-site-Styles-highlightMe">libraryDependencies += &quot;org.scalameta&quot; %% &quot;contrib&quot; % &quot;3.2.0&quot;
</code></pre>
  <h1 id="Tutorial" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Tutorial" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Tutorial</h1>
    The examples mentioned in this tutorial are available in a single repository
    that you can clone and run locally.
    <ol>
      <li>
        Clone the <a href="https://github.com/scalameta/tutorial">accompanying repo</a>.</li>
      <li>
        Run <code>sbt test</code> to make sure everything works.</li>
      <li>
        Open the file <code>Playground.scala</code>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">package scalaworld

import scala.meta._
import org.scalameta.logger // useful for debugging

class Playground extends org.scalatest.FunSuite {
  import scala.meta._

  test(&quot;part 1: tokens&quot;) {
    val tokens = &quot;val x = 2&quot;.tokenize.get
    logger.elem(tokens.syntax)
    logger.elem(tokens.structure)
  }

  test(&quot;part 2: trees&quot;) {
    val tree = &quot;val x = 2&quot;.parse[Stat].get
    logger.elem(tree.syntax)
    logger.elem(tree.structure)
  }

}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/scalameta/scalameta-tutorial/tree/master/library/src/test/scala/scalaworld/Playground.scala#L0-L21" target="_blank"><i class="fa fa-link "></i></a></pre></li>
      <li>
        To test playground on every edit, run <code>sbt ~library/test</code>.</li>
      <li>
        Setup the project in your favorite IDE, for example IntelliJ, ENSIME or vim.
</li></ol>
  <h1 id="AmmoniteREPL" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#AmmoniteREPL" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Ammonite REPL</h1>
    To experiment with Scalameta in the REPL, you can run the following
    in the <a href="http://www.lihaoyi.com/Ammonite/#Ammonite-REPL">Ammonite REPL</a>
    <pre><code class="scala scalatex-site-Styles-highlightMe">import $ivy.`org.scalameta:scalameta_2.12:3.2.0`, scala.meta._</code></pre>

  

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Tokens" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Tokens<a class=" scalatex-site-Styles-headerLink" href="#Tokens" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
  <p>
    Make sure you have Scalameta installed as a library from <a href="#Setup">Setup</a>.

    You can decide to run these examples from the console or from sbt,
    for example in the tutorial repo.
</p>
  <p>
    This whole workshop will assume you have this import in scope:
</p>
  <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; import scala.meta._
import scala.meta._</code></pre>
  <p>
    Here's how to tokenize a small expression.

    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;val x = 2&quot;.tokenize.get
res0: scala.meta.tokens.Tokens = Tokens(, val,  , x,  , =,  , 2, )</code></pre>
    Let's discuss the most interesting methods on tokens.

    <h1 id="Tokens.syntax" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Tokens.syntax" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Tokens.syntax</h1>
      <p>
        The simplest method we can call is <code>Tokens.syntax</code>
        The method returns a string representation of the actual code behind
        the tokens, or how the code should look like to a developer.
</p>
      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;val x = 2&quot;.tokenize.get.syntax
res0: String = val x = 2</code></pre>
      <p>
        <code>Tokens.toString()</code> uses <code>.syntax</code> behind the scenes.
        However, you should never rely on <code>toString()</code> when manipulating
        Scalameta structures, prefer to explicitly call <code>.syntax</code>.
        It's maybe not so obvious why right now but it will make more sense soon.
</p>
    <h1 id="Tokens.structure" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Tokens.structure" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Tokens.structure</h1>
      <p>
        Another useful method is <code>Tokens.structure</code>.
        The method shows details that may be relevant to us as metaprogrammers.

        <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;val x = 2&quot;.tokenize.get.structure
res0: String = Tokens(BOF [0..0), val [0..3),   [3..4), x [4..5),   [5..6), = [6..7),   [7..8), 2 [8..9), EOF [9..9))</code></pre></p>
      <p>
        <code>.structure</code> is often useful for debugging and testing.
</p>
    <h1 id="Tokensvs.Token" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Tokensvs.Token" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Tokens vs. Token</h1>
      <p>
        The class <code>Tokens</code> is a wrapper around a sequence of <code>Token</code> objects.
        There are multiple subtypes of <code>Token</code> while there only one type <code>Tokens</code>.

        <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;val x = 2&quot;.tokenize.get.head
res0: scala.meta.tokens.Token =</code></pre></p>
       <code>BOF</code> stands for &quot;Beginning of file&quot;.
       Let's see what other kinds of token types are in the string

        <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;val x = 2&quot;.tokenize.get.
  map(x =&gt; f&quot;${x.structure}%10s -&gt; ${x.productPrefix}&quot;).
  mkString(&quot;\n&quot;)
res0: String =
BOF [0..0) -&gt; BOF
val [0..3) -&gt; KwVal
    [3..4) -&gt; Space
  x [4..5) -&gt; Ident
    [5..6) -&gt; Space
  = [6..7) -&gt; Equals
    [7..8) -&gt; Space
  2 [8..9) -&gt; Int
EOF [9..9) -&gt; EOF</code></pre>
        <p>
          Even spaces get their own tokens.
          The <code>[0...3)</code> part indicates that the <code>val</code> tokens start at
          offset 0 and ends at offset 3.
</p>
    <h1 id="==" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#==" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>==</h1>
      <p>
        How does token equality look like?
</p>
      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;foobar&quot;.tokenize.get(1) == &quot;foobar kas&quot;.tokenize.get(1)
res0: Boolean = false</code></pre>
      Huh, why are they not the same?

      <div class="bs-callout bs-callout-warning"><p>
        Token equality is implemented with reference equality.
        You need to be explicit if you actually mean syntactic (<code>.syntax</code>),
        or structural (<code>.structure</code>) equality.
</p></div>
      The tokens are syntactically equal.

      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;foobar&quot;.tokenize.get(1).syntax == &quot;foobar kas&quot;.tokenize.get(1).syntax
res0: Boolean = true</code></pre>
      Even if we move the tokens around

      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;kas foobar&quot;.tokenize.get(3).syntax == &quot;foobar kas&quot;.tokenize.get(1).syntax
res0: Boolean = true</code></pre>
      The tokens are also structurally equal.

      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;foobar&quot;.tokenize.get(1).structure == &quot;foobar kas&quot;.tokenize.get(1).structure
res0: Boolean = true</code></pre>
      However, they are not structurally equal if we move them around.

      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;kas foobar&quot;.tokenize.get(3).structure == &quot;foobar kas&quot;.tokenize.get(1).structure
res0: Boolean = false</code></pre>
    <h1 id=".get" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#.get" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>.get</h1>
      <p>
        Tokenization can sometimes fail, for example in this case:

        <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;&quot;&quot; val str = &quot;unclosed literal &quot;&quot;&quot;.tokenize
res0: scala.meta.tokenizers.Tokenized =
&lt;input&gt;:1: error: unclosed string literal
 val str = &quot;unclosed literal
           ^</code></pre>
        <p>
          If you prefer, you can safely pattern match on the tokenize result

          <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;&quot;&quot; val str = &quot;closed literal&quot; &quot;&quot;&quot;.tokenize match {
  case tokenizers.Tokenized.Success(tokenized) =&gt; tokenized
  case tokenizers.Tokenized.Error(e, _, _) =&gt; ???
}
res0: scala.meta.tokens.Tokens = Tokens(,  , val,  , str,  , =,  , &quot;closed literal&quot;,  , )</code></pre></p></p></p>
  <h1 id="Conclusion" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Conclusion" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Conclusion</h1>
    <p>
      Scalameta tokens are the foundation of Scalameta.
      Sometimes you don't have access to a parsed AST and then your best shot is
      work with tokens.
</p>
    <p>
      In the following chapter we will discuss another exciting data structure:
      the incredible <b>scala.meta.Tree</b>.</p>

  

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Trees" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Trees<a class=" scalatex-site-Styles-headerLink" href="#Trees" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
  <p>
    Reminder. We assume you have this import in scope:
</p>
  <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; import scala.meta._
import scala.meta._</code></pre>
  <h1 id="q&quot;Quasiquotes&quot;" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#q&quot;Quasiquotes&quot;" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>q&quot;Quasiquotes&quot;</h1>
    <p>
      The easiest way to get started with Scalameta trees is using quasiquotes.
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; q&quot;case class User(name: String, age: Int)&quot;
res0: meta.Defn.Class = case class User(name: String, age: Int)</code></pre>
    <p>
      Quasiquotes can be composed
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; val method = q&quot;def `is a baby` = age &lt; 1&quot;
method: meta.Defn.Def = def `is a baby` = age &lt; 1

scala&gt; q&quot;&quot;&quot;
case class User(name: String, age: Int) {
  $method
}
&quot;&quot;&quot;
res0: meta.Defn.Class = case class User(name: String, age: Int) { def `is a baby` = age &lt; 1 }</code></pre>
    <p>
      Quasiquotes can also be used to deconstruct trees with pattern matching
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; q&quot;def `is a baby` = age &lt; 1&quot; match {
  case q&quot;def $name = $body&quot; =&gt;
    s&quot;You ${name.syntax} if your ${body.syntax}&quot;
}
res0: String = You `is a baby` if your age &lt; 1</code></pre>
    <div class="bs-callout bs-callout-warning"><p>
      <b>NOTE</b>. Quasiquotes currently ignore comments:

      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; q&quot;val x = 2 // assignment&quot;.syntax
res0: String = val x = 2</code></pre>
      If you need comments, you can use <a href="#.parse[T]">.parse[T]</a>

      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;val x = 2 // assignment&quot;.parse[Stat].get.syntax
res0: String = val x = 2 // assignment</code></pre></p></div>
  <h1 id=".parse[T]" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#.parse[T]" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>.parse[T]</h1>
    <p>
      If the contents that you want to parse are only known at runtime,
      you can't use quasiquotes.
      For example, this happens when you need to parse file contents.
</p>
    <p>
      Here's how to parse a compilation unit.
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;object Main extends App { println(1) }&quot;.parse[Source].get
res0: scala.meta.Source = object Main extends App { println(1) }</code></pre>
    <div class="bs-callout bs-callout-success"><p>
      Pro tip. You can also call <code>.parse[T]</code> on a <code>File</code>,
      just like this

      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; new java.io.File(&quot;readme/ParseMe.scala&quot;).parse[Source]
res0: scala.meta.parsers.Parsed[scala.meta.Source] =
class ParseMe { println(&quot;I'm inside a file&quot;) }</code></pre></p></div>
    <p>
      If we try to parse a statement as a compilation unit we will fail.
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;val x = 2&quot;.parse[Source]
res0: scala.meta.parsers.Parsed[scala.meta.Source] =
&lt;input&gt;:1: error: expected class or object definition
val x = 2
^</code></pre>
    <p>
      We need to explicitly parse it as a statement (<code>Stat</code>).
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;val x = 2&quot;.parse[Stat].get
res0: scala.meta.Stat = val x = 2</code></pre>
    <p>
      We can also parse case statement
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;case Foo(bar) if bar &gt; 2 =&gt; println(bar)&quot;.parse[Case].get
res0: scala.meta.Case = case Foo(bar) if bar &gt; 2 =&gt; println(bar)</code></pre>
    <p>
      Scalameta has dozens of parsers:
      <div class="text-center"><img style="width: 100%" src="img/parse.png" /><p></p></div>
      However, <code>.parse[Stat]</code> and <code>.parse[Source]</code> are
      usually all you need. However, a comprehensive list of the parsers,
      and their quasiquote syntax is <a href="https://github.com/scalameta/scalameta/blob/master/notes/quasiquotes.md">documented here</a>.
</p>
  <h1 id="Dialects" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Dialects" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Dialects</h1>
    <p>
      I didn't tell the whole story when I said you need to pass in a type
      argument to parse statements.
      You also need to pass in a dialect!
      However, Scalameta will by default pick the <code>Scala211</code> dialect
      for you if you don't provide one explicitly.
</p>
    <p>
      With the SBT dialects, we can parse vals as top-level statements.
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; dialects.Sbt0137(
  &quot;lazy val core = project.settings(commonSettings)&quot;
).parse[Source].get
res0: scala.meta.Source = lazy val core = project.settings(commonSettings)</code></pre>
    <p>
      We can even parse multiple top level statements
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; dialects.Sbt0137(
  &quot;&quot;&quot;
  lazy val core = project.settings(commonSettings)

  lazy val extra = project.dependsOn(core)
  &quot;&quot;&quot;
).parse[Source].get
res0: scala.meta.Source =

  lazy val core = project.settings(commonSettings)

  lazy val extra = project.dependsOn(core)</code></pre>
    <p>
      For the remainder of the workshop, we will only work with the <code>Scala211</code>
      dialect.
</p>
  <h1 id="Tree.syntax" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Tree.syntax" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Tree.syntax</h1>
    <p>
      Just like with tokens, we can also run <code>.syntax</code> on trees.
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;foo(bar)&quot;.parse[Stat].get.syntax
res0: String = foo(bar)</code></pre>
    However, Scalameta can also do this even if you manually construct the tree

    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; Term.Apply(
  Term.Name(&quot;foo&quot;),
  Term.Name(&quot;bar&quot;) :: Nil
).syntax
res0: String = foo(bar)</code></pre>
    <p>
      We never gave Scalameta parentheses but still it figured out we needed
      them.
      Pretty cool huh.
</p>
  <h1 id="Tree.structure" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Tree.structure" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Tree.structure</h1>
    <p>
      Just like with tokens, we can also run <code>.structure</code> on trees.
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;foo(bar)&quot;.parse[Stat].get.structure
res0: String = Term.Apply(Term.Name(&quot;foo&quot;), List(Term.Name(&quot;bar&quot;)))</code></pre>
    <p>
      <code>.structure</code> ignores any syntactic trivia like whitespace and comments
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;foo  ( /* this is a comment */ bar  ) // eol&quot;.parse[Stat].get.structure
res0: String = Term.Apply(Term.Name(&quot;foo&quot;), List(Term.Name(&quot;bar&quot;)))</code></pre>
    <p>
      This can be useful for example in debugging, testing or equality checking.
</p>
  <h1 id="Tree.collect" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Tree.collect" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Tree.collect</h1>
    <p>
      You can collect on Scalameta.Tree just like regular collections.
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; source&quot;&quot;&quot;sealed trait Op[A]
    object Op extends B {
      case class Foo(i: Int) extends Op[Int]
      case class Bar(s: String) extends Op[String]
    }&quot;&quot;&quot;.collect { case cls: Defn.Class =&gt; cls.name }
res0: List[meta.Type.Name] = List(Foo, Bar)</code></pre>
  <h1 id="Tree.transform" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Tree.transform" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Tree.transform</h1>
    <p>
      Transform Scalameta.Tree with <code>.transform</code>.
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; q&quot;myList.filter(_ &gt; 3 + a).headOption // comments are removed :(&quot;.transform {
  case q&quot;$lst.filter($cond).headOption&quot; =&gt; q&quot;$lst.find($cond)&quot;
}
res0: scala.meta.Tree = myList.find(_ &gt; 3 + a)</code></pre>
    <div class="bs-callout bs-callout-warning"><p>
      <code>.transform</code> does not preserve syntactic details such as comments
      and formatting. There has been made some work on source aware transformation,
      see <a href="https://github.com/scalameta/scalameta/pull/457">#457</a>,
      but it still requires a bit more work.
</p></div>
  <h1 id="Tree.==" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Tree.==" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Tree.==</h1>
    <p>
      Just like with tokens, tree equality is by default by reference:
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; q&quot;foo(bar)&quot; == q&quot;foo(bar)&quot;
res0: Boolean = false</code></pre>
    This means you need to be explicit if you mean syntactic equality

    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; q&quot;foo(bar)&quot;.syntax == q&quot;foo(bar)&quot;.syntax
res0: Boolean = true</code></pre>
    <p>
      or structural equality
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; q&quot;foo(bar)&quot;.structure == q&quot;foo(bar)&quot;.structure
res0: Boolean = true</code></pre>
  <h1 id="Comprehensivetrees" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Comprehensivetrees" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Comprehensive trees</h1>
    <p>
      A key feature of Scalameta trees is that they comprehensively cover
      all corners of the Scala syntax.
      A side effect of this is that the Scalameta tree hierarchy contains a
      lot of types.
      For example, there is a different tree node for an abstract <code>def</code> (<code>Decl.Def</code>)

      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; q&quot;def add(a: Int, b: Int)&quot; // Decl.Def
res0: meta.Decl.Def = def add(a: Int, b: Int): Unit</code></pre>
      and a <code>def</code> with an implementation (<code>Defn.Def</code>)

      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; q&quot;def add(a: Int, b: Int) = a + b&quot; // Defn.Def
res0: meta.Defn.Def = def add(a: Int, b: Int) = a + b</code></pre>
      <p>
        Fortunately, most of the time you won't need to worry about this.
        Quasiquotes help you create/match/compose/deconstruct the correct instances.
        However, occasionally you may need to debug the types of the trees you have.
</p>
      <p>
        For your convenience, we've compiled together the most common types in
        this handy diagram:
        <div class="text-center"><img style="width: 100%" src="img/tree.png" /><p></p></div></p></p>

  

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="SemanticAPI" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Semantic API<a class=" scalatex-site-Styles-headerLink" href="#SemanticAPI" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
  The semantic API offers operations to query information from the Scala compiler
  such as name resolution (<code>println</code> =&gt; <code>_root_.scala.Predef.println</code>),
  symbol signatures (<code>_root_.com.Example.main([Ljava/lang/String;)V.</code> =&gt;
  <code>def main(args: Array[String]): Unit</code>),
  These operations can for example be used by tools like
  <a href="https://scalacenter.github.io/scalafix">Scalafix</a>,
  <a href="http://scalameta.org/metadoc/">Metadoc</a>,
  <a href="https://geirsson.com/assets/metals/">Metals</a>.

  <h1 id="SemanticDB" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#SemanticDB" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>SemanticDB</h1>
    <p>
      SemanticDB is a data model for semantic information about programs in Scala and
      other languages. SemanticDB decouples production and consumption of semantic information,
      establishing documented means for communication between tools.
</p>
    <p>
      The storage format used for the SemanticDB is defined using
      <a href="https://developers.google.com/protocol-buffers/">Protocol Buffers</a>,
      or &quot;protobuf&quot; for short. The full schema is available
      <a href="https://github.com/scalameta/scalameta/blob/master/semanticdb/README.md">here</a>.
      Files containing SemanticDB binary data use the <code>.semanticdb</code> file
      extension by convention.
</p>
    <p>
      At the time of writing, SemanticDB has an experimental status and
      the associated APIs are considered internal. If you'd like to learn more,
      ask on our gitter channel: <a href="https://gitter.im/scalameta/scalameta?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge"><img src="https://camo.githubusercontent.com/da2edb525cde1455a622c58c0effc3a90b9a181c/68747470733a2f2f6261646765732e6769747465722e696d2f4a6f696e253230436861742e737667" alt="Join the chat at https://gitter.im/scalameta/scalameta" data-canonical-src="https://badges.gitter.im/Join%20Chat.svg" style="max-width:100%;"></a></p>

  

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Contrib" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Contrib<a class=" scalatex-site-Styles-headerLink" href="#Contrib" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
  Scalameta contrib is a module that provides common utilities for handling
  Scalameta data structures.

  <p>
    To use contrib, <code>import scala.meta.contrib._</code>.
</p>
  <p>
    Contrib exposes some collection-like methods on <code>Tree</code>.
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; source&quot;&quot;&quot;
class A
trait B
object C
object D
&quot;&quot;&quot;.find(_.is[Defn.Object])
res0: Option[scala.meta.Tree] = Some(object C)

scala&gt; source&quot;&quot;&quot;
class A
trait B
object C {
  val x = 2
  val y = 3
}
object D
&quot;&quot;&quot;.collectFirst { case q&quot;val y = $body&quot; =&gt;  body.structure }
res1: Option[String] = Some(Lit.Int(3))

scala&gt; source&quot;&quot;&quot;
class A
trait B
object C {
  val x = 2
  val y = 3
}
object D
&quot;&quot;&quot;.exists(_.is[Defn.Def])
res2: Boolean = false</code></pre></p>
  <p>
    Contrib has a <code>Equal</code> typeclass for comparing trees by structural or
    syntactic equality.
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; q&quot;val x = 2&quot;.isEqual(q&quot;val x = 1&quot;)
res0: Boolean = false

scala&gt; (q&quot;val x = 2&quot;: Stat).isEqual(&quot;val x = 2 // comment&quot;.parse[Stat].get)
res1: Boolean = true

scala&gt; (q&quot;val x = 2&quot;: Stat).isEqual[Syntactically](&quot;val x = 2 // comment&quot;.parse[Stat].get)
res2: Boolean = false

scala&gt; q&quot;lazy val x = 2&quot;.mods.exists(_.isEqual(mod&quot;lazy&quot;))
res3: Boolean = true

scala&gt; q&quot;lazy val x = 2&quot;.contains(q&quot;3&quot;)
res4: Boolean = false

scala&gt; q&quot;lazy val x = 2&quot;.contains(q&quot;2&quot;)
res5: Boolean = true</code></pre></p>
  <p>
    Contrib has an <code>AssociatedCommments</code> helper to extract leading
    and trailing comments of tree nodes.
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; val code: Source = &quot;&quot;&quot;
/** This is a docstring */
trait MyTrait // leading comment
&quot;&quot;&quot;.parse[Source].get
code: scala.meta.Source =

/** This is a docstring */
trait MyTrait // leading comment

scala&gt; val comments = AssociatedComments(code)
comments: scala.meta.contrib.AssociatedComments =
AssociatedComments(
  Leading =
    trait [28..33) =&gt; List(/**∙This∙is∙a∙docstring∙*/)

  Trailing =

)

scala&gt; val myTrait = code.find(_.is[Defn.Trait]).get
myTrait: scala.meta.Tree = trait MyTrait

scala&gt; comments.leading(myTrait) -&gt; comments.trailing(myTrait)
res0: (Set[meta.tokens.Token.Comment], Set[meta.tokens.Token.Comment]) = (Set(/** This is a docstring */),Set())</code></pre></p>

  

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="FAQ" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">FAQ<a class=" scalatex-site-Styles-headerLink" href="#FAQ" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
  <h1 id="Macros?" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Macros?" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Macros?</h1>
    Originally, Scalameta was founded to become a better macro system for Scala,
    but over time we shifted focus to developer tools and spun off the new macro system
    into a separate project: <a href="https://github.com/scalacenter/macros">scalacenter/macros</a>.

  <h1 id="WhatisthequasiquoteforX?" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#WhatisthequasiquoteforX?" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>What is the quasiquote for X?</h1>
    Here is an overview of quasiquote syntax: <a href="https://github.com/scalameta/scalameta/blob/master/notes/quasiquotes.md">https://github.com/scalameta/scalameta/blob/master/notes/quasiquotes.md</a>.

  <h1 id="CanIuseScalametawithScala.js?" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#CanIuseScalametawithScala.js?" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Can I use Scalameta with Scala.js?</h1>
    Yes, the main Scalameta modules support Scala.js.

  <h1 id="CanIuseScalametawithScalaNative?" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#CanIuseScalametawithScalaNative?" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Can I use Scalameta with Scala Native?</h1>
    No, but we're <a href="https://github.com/scalameta/scalameta/issues/772">almost there</a>.

  <h1 id="I'dliketousetheSemanticAPIasareplacementforscalac's
presentationcompiler,isthisdoable?intendedusage?" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#I'dliketousetheSemanticAPIasareplacementforscalac's
presentationcompiler,isthisdoable?intendedusage?" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>I'd like to use the Semantic API as a replacement for scalac's
        presentation compiler, is this doable? intended usage?</h1>
    In principle, this should be doable, but it requires custom development
    and is not supported at the moment.

  <h1 id="HowdoIusetheSemanticAPI" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#HowdoIusetheSemanticAPI" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>How do I use the Semantic API</h1>
    See <a href="https://scalacenter.github.io/scalafix/#scalacenter/scalafix.g8">scalacenter/scalafix.g8</a>.

  <h1 id="DoesScalametaintegratewithZincinordertoachievetheSemanticAPI?" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#DoesScalametaintegratewithZincinordertoachievetheSemanticAPI?" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Does Scalameta integrate with Zinc in order to achieve the Semantic API?</h1>
    No, Zinc and Scalameta and unrelated.  The Scalameta Semantic
    API is enabled with a scalac compiler plugin called semanticdb-scalac.
    semanticdb-scalac is designed to accommodate incremental compilation in order to
    play nicely with Zinc.

  <h1 id="WherecanIaskmorequestions?" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#WherecanIaskmorequestions?" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Where can I ask more questions?</h1>
    <ul>
      <li>
        use the
        <a href="http://stackoverflow.com/questions/tagged/scala-meta">scala-meta</a>.
        tag on Stack Overflow.</li>
      <li>
        We also have a Gitter channel
        
          <a href="https://gitter.im/scalameta/scalameta?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge"><img src="https://camo.githubusercontent.com/da2edb525cde1455a622c58c0effc3a90b9a181c/68747470733a2f2f6261646765732e6769747465722e696d2f4a6f696e253230436861742e737667" alt="Join the chat at https://gitter.im/scalameta/scalameta" data-canonical-src="https://badges.gitter.im/Join%20Chat.svg" style="max-width:100%;"></a>
</li></ul>

  


  <!-- Latest compiled and minified CSS -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <style>
    .bs-callout-danger {
      border-left-color: #ce4844 !IMPORTANT;
    }
    .bs-callout-danger h4 {
      color: #ce4844 !IMPORTANT;
    }
    .bs-callout-warning {
      border-left-color: #aa6708 !IMPORTANT;
    }
    .bs-callout-warning h4 {
      color: #aa6708 !IMPORTANT;
    }
    .bs-callout-info {
      border-left-color: #1b809e !IMPORTANT;
    }
    .bs-callout-info h4 {
      color: #1b809e !IMPORTANT;
    }
    .bs-callout-success {
      border-left-color: #5cb85c !IMPORTANT;
    }
    .bs-callout {
        padding: 20px;
        margin: 20px 0;
        border: 1px solid #eee;
        border-left-width: 5px;
        border-radius: 3px;
    }
    .scalatex-site-Styles-headerTag {
      margin-bottom: 20px !important;
    }
  </style>

</div>

  <script type="text/javascript">
    var _paq = _paq || [];
    _paq.push(["setDomains", ["*.scalameta.org"]]);
    _paq.push(['trackPageView']);
    _paq.push(['enableLinkTracking']);
    (function() {
      var u="https://stats.geirsson.com/hello/";
      _paq.push(['setTrackerUrl', u+'hello.php']);
      _paq.push(['setSiteId', 4]);
      var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
      g.type='text/javascript'; g.async=true; g.defer=true; g.src=u+'hello.js'; s.parentNode.insertBefore(g,s);
    })();
  </script>
  <noscript><p><img src="https://stats.geirsson.com/hello/hello.php?idsite=4" style="border:0;" alt="" /></p></noscript>
</div><script>
    scalatex.scrollspy.Controller().main(
      [{"value":"A Whirlwind Tour of Scalameta","children":[{"value":"Setup","children":[{"value":"Library","children":[]},{"value":"Tutorial","children":[]},{"value":"Ammonite REPL","children":[]}]},{"value":"Tokens","children":[{"value":"Tokens.syntax","children":[]},{"value":"Tokens.structure","children":[]},{"value":"Tokens vs. Token","children":[]},{"value":"==","children":[]},{"value":".get","children":[]},{"value":"Conclusion","children":[]}]},{"value":"Trees","children":[{"value":"q\"Quasiquotes\"","children":[]},{"value":".parse[T]","children":[]},{"value":"Dialects","children":[]},{"value":"Tree.syntax","children":[]},{"value":"Tree.structure","children":[]},{"value":"Tree.collect","children":[]},{"value":"Tree.transform","children":[]},{"value":"Tree.==","children":[]},{"value":"Comprehensive trees","children":[]}]},{"value":"Semantic API","children":[{"value":"SemanticDB","children":[]}]},{"value":"Contrib","children":[]},{"value":"FAQ","children":[{"value":"Macros?","children":[]},{"value":"What is the quasiquote for X?","children":[]},{"value":"Can I use Scalameta with Scala.js?","children":[]},{"value":"Can I use Scalameta with Scala Native?","children":[]},{"value":"I'd like to use the Semantic API as a replacement for scalac's\n        presentation compiler, is this doable? intended usage?","children":[]},{"value":"How do I use the Semantic API","children":[]},{"value":"Does Scalameta integrate with Zinc in order to achieve the Semantic API?","children":[]},{"value":"Where can I ask more questions?","children":[]}]}]}]
  )</script><script>
    ['DOMContentLoaded', 'load'].forEach(function(ev){
      addEventListener(ev, function(){
        Array.prototype.forEach.call(
          document.getElementsByClassName('scalatex-site-Styles-highlightMe'),
          hljs.highlightBlock
        );
      })
    })
  </script></body></html>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    